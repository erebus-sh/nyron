/**
 * @fileoverview Commit parsing and organization utilities for changelog generation.
 * 
 * This module provides comprehensive tools for parsing conventional commits,
 * filtering out automated commits, and organizing commit data into structured
 * formats suitable for changelog generation. It supports the full conventional
 * commits specification with enhanced formatting for GitHub integration.
 * 
 * @author Nyron CLI
 * @version 1.0.0
 * @since 1.0.0
 */

import type { CommitDiff, ParsedCommits } from "./types"

/**
 * Filters out meta commits (version bumps, changelog updates) from a list of commits.
 * 
 * Meta commits are typically generated by automated versioning tools and don't represent
 * actual user-facing changes. This function identifies and removes these commits to ensure
 * clean changelog generation that focuses on meaningful changes.
 * 
 * @param commits - Array of commit objects to filter
 * @returns Array of commits with meta commits removed, preserving only user-relevant changes
 * 
 * @example
 * ```typescript
 * const filteredCommits = filterMetaCommits([
 *   { message: "feat: add new feature", ... },
 *   { message: "chore: bump version to 1.2.0", ... },
 *   { message: "fix: resolve bug", ... }
 * ]);
 * // Returns only feat and fix commits, excluding the version bump
 * ```
 */
export function filterMetaCommits(commits: CommitDiff[]): CommitDiff[] {
  return commits.filter(commit => {
    const msg = commit.message.toLowerCase()
    return !(
      msg.includes('bump') && msg.includes('version') ||
      msg.includes('update changelog') ||
      msg.startsWith('chore: bump') ||
      msg.startsWith('chore: update changelog')
    )
  })
}


/**
 * Parses an array of commits into structured groups based on conventional commit format.
 * 
 * This function analyzes commit messages following the conventional commits specification
 * (https://www.conventionalcommits.org/) and organizes them into a hierarchical structure
 * by type and scope. Commits that don't match the conventional format are grouped under "other".
 * 
 * @param commits - Array of commit objects to parse
 * @returns Parsed commits organized by type and scope in the format:
 *          `{ "Features": { "scope1": [...], "general": [...] }, ... }`
 * 
 * @example
 * ```typescript
 * const parsed = parseCommits([
 *   { message: "feat(api): add authentication", ... },
 *   { message: "fix: resolve memory leak", ... },
 *   { message: "chore: update dependencies", ... }
 * ]);
 * // Returns:
 * // {
 * //   "Features": { "api": [{ type: "Features", scope: "api", message: "add authentication", ... }] },
 * //   "Bug Fixes": { "general": [{ type: "Bug Fixes", scope: "general", message: "resolve memory leak", ... }] },
 * //   "Chores": { "general": [{ type: "Chores", scope: "general", message: "update dependencies", ... }] }
 * // }
 * ```
 */
export function parseCommits(commits: CommitDiff[]): ParsedCommits {
  const groups: ParsedCommits = {}

  for (const commit of commits) {
    const raw = commit.message.trim()

    // Match conventional commits: type(scope?): message
    const match = raw.match(/^(\w+)(?:\(([^)]+)\))?:\s*(.+)$/)
    if (!match) {
      // fallback bucket
      groups["other"] ??= { ["general"]: [] }
      if (!groups["other"]["general"]) groups["other"]["general"] = []
      groups["other"]["general"].push({ 
        type: "other", 
        message: raw, 
        raw, 
        author: commit.author, 
        hash: commit.hash, 
        repo: commit.repo,
        githubUser: commit.githubUser,
        avatar: commit.avatar,
        url: commit.url
      })
      continue
    }

    const [, type, scope, message] = match
    const normalizedType = normalizeType(type as string)

    // ensure structure
    if (!groups[normalizedType]) groups[normalizedType] = {}
    const scopeKey = scope ?? "general"
    if (!groups[normalizedType][scopeKey]) groups[normalizedType][scopeKey] = []

    groups[normalizedType][scopeKey].push({ 
      type: normalizedType, 
      scope: scopeKey as string, 
      message: message!, 
      raw, 
      author: commit.author, 
      hash: commit.hash, 
      repo: commit.repo,
      githubUser: commit.githubUser,
      avatar: commit.avatar,
      url: commit.url
    })
  }
  return groups
}

/**
 * Normalizes commit types into canonical groups for changelog generation.
 * 
 * Maps conventional commit types to human-readable category names that are
 * suitable for display in changelogs and release notes.
 * 
 * @param type - The raw commit type from the conventional commit message
 * @returns The normalized type name for changelog categorization
 * 
 * @example
 * ```typescript
 * normalizeType("feat")     // Returns "Features"
 * normalizeType("fix")      // Returns "Bug Fixes"
 * normalizeType("refactor") // Returns "Refactors"
 * normalizeType("unknown")  // Returns "Other"
 * ```
 */
function normalizeType(type: string): string {
  switch (type) {
    case "feat":
      return "Features"
    case "fix":
      return "Bug Fixes"
    case "refactor":
      return "Refactors"
    case "perf":
      return "Performance"
    case "docs":
      return "Docs"
    case "chore":
      return "Chores"
    case "test":
      return "Tests"
    case "style":
      return "Style"
    default:
      return "Other"
  }
}

/**
 * Represents commits organized into changelog-friendly categories.
 * 
 * Each array contains formatted commit strings ready for inclusion in changelog
 * generation, with proper markdown formatting, author attribution, and commit links.
 */
export interface OrganizedCommits {
  /** Array of formatted feature commit strings */
  features: string[]
  /** Array of formatted bug fix commit strings */
  fixes: string[]
  /** Array of formatted chore/other commit strings */
  chores: string[]
}

/**
 * Organizes parsed commits into changelog-friendly categories with rich formatting.
 * 
 * This function transforms the structured commit data into formatted strings suitable
 * for changelog generation. Each commit is formatted with scope labels (when applicable),
 * author attribution with GitHub links, and commit hash links for easy navigation.
 * 
 * @param parsedCommits - The result from parseCommits() containing structured commit data
 * @returns An object containing three arrays of formatted commit strings:
 *          - `features`: New features and enhancements
 *          - `fixes`: Bug fixes and corrections  
 *          - `chores`: Chores, refactors, docs, tests, and other changes
 * 
 * @example
 * ```typescript
 * const parsed = parseCommits(commits);
 * const organized = organizeForChangelog(parsed);
 * // Returns:
 * // {
 * //   features: ["**api**: add authentication ([@user](https://github.com/user)) [[abc1234](https://github.com/repo/commit/abc1234...)]"],
 * //   fixes: ["resolve memory leak ([@user](https://github.com/user)) [[def5678](https://github.com/repo/commit/def5678...)]"],
 * //   chores: ["update dependencies ([@user](https://github.com/user)) [[ghi9012](https://github.com/repo/commit/ghi9012...)]"]
 * // }
 * ```
 */
export function organizeForChangelog(parsedCommits: ParsedCommits): OrganizedCommits {
  const features: string[] = []
  const fixes: string[] = []
  const chores: string[] = []
  
  // Process Features
  if (parsedCommits["Features"]) {
    for (const [scope, commits] of Object.entries(parsedCommits["Features"])) {
      for (const commit of commits) {
        const scopeLabel = scope !== "general" ? `**${scope}**: ` : ""
        const authorLink = commit.githubUser 
          ? `[@${commit.githubUser}](https://github.com/${commit.githubUser})`
          : commit.author
        const commitLink = commit.url || `https://github.com/${commit.repo}/commit/${commit.hash}`
        const shortHash = commit.hash.substring(0, 7)
        features.push(`${scopeLabel}${commit.message} (${authorLink}) [[${shortHash}](${commitLink})]`)
      }
    }
  }
  
  // Process Bug Fixes
  if (parsedCommits["Bug Fixes"]) {
    for (const [scope, commits] of Object.entries(parsedCommits["Bug Fixes"])) {
      for (const commit of commits) {
        const scopeLabel = scope !== "general" ? `**${scope}**: ` : ""
        const authorLink = commit.githubUser 
          ? `[@${commit.githubUser}](https://github.com/${commit.githubUser})`
          : commit.author
        const commitLink = commit.url || `https://github.com/${commit.repo}/commit/${commit.hash}`
        const shortHash = commit.hash.substring(0, 7)
        fixes.push(`${scopeLabel}${commit.message} (${authorLink}) [[${shortHash}](${commitLink})]`)
      }
    }
  }
  
  // Process Chores and other types
  const choreTypes = ["Chores", "Refactors", "Performance", "Docs", "Tests", "Style", "Other", "other"]
  for (const type of choreTypes) {
    if (parsedCommits[type]) {
      for (const [scope, commits] of Object.entries(parsedCommits[type])) {
        for (const commit of commits) {
          const scopeLabel = scope !== "general" ? `**${scope}**: ` : ""
          const authorLink = commit.githubUser 
            ? `[@${commit.githubUser}](https://github.com/${commit.githubUser})`
            : commit.author
          const commitLink = commit.url || `https://github.com/${commit.repo}/commit/${commit.hash}`
          const shortHash = commit.hash.substring(0, 7)
          chores.push(`${scopeLabel}${commit.message} (${authorLink}) [[${shortHash}](${commitLink})]`)
        }
      }
    }
  }
  
  return { features, fixes, chores }
}
